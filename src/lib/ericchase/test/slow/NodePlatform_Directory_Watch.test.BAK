import { afterEach, beforeEach, describe, expect, test } from 'bun:test';
import { Core_Error_Fix_Call_Stack_Async } from '../../Core_Error_Fix_Call_Stack.js';
import { Core_Promise_Deferred_Class } from '../../Core_Promise_Deferred_Class.js';
import { NodePlatform_Directory_Create_Async } from '../../NodePlatform_Directory_Create.js';
import { NodePlatform_Directory_Delete_Async } from '../../NodePlatform_Directory_Delete.js';
import { Async_Is_WSL, NodePlatform_Directory_Watch_Async, Type_NodePlatform_Directory_Watch_Options } from '../../NodePlatform_Directory_Watch_Async.original.BAK';
import { NodePlatform_SetupTempDirectory_Async, path_case_dir, path_case_dir_subdir, temp_nonexistent_path } from '../test-setup.js';

await Core_Error_Fix_Call_Stack_Async(Error().stack, NodePlatform_SetupTempDirectory_Async());

let async_globalUnwatch: Function | undefined;
let test_pass = '';

/**
 * WSL (Windows Subsystem for Linux) does not properly handle filesystem
 * notifications. The core problem is that inotify, which Chokidar (via
 * fsevents/fs.watch/fs.watchFile) depends on, does not work reliably in
 * certain WSL scenariosâ€”especially after directory deletions and
 * recreations. The only reasonable workaround, as far as I can tell, is to
 * set `alwaysStat` and `usePolling` to `true, and then choose appropriate
 * values for `binaryInterval` and `interval` when WSL is detected. This API
 * will initialize those options automatically with reasonable values when
 * WSL is detected. User provided values will always take precedence. For
 * these test cases, extremely short intervals are used because the tests are
 * short and deterministic.
 */
const watcher_options: Type_NodePlatform_Directory_Watch_Options =
  (await Async_Is_WSL()) === true
    ? {
        binaryInterval: 25,
        interval: 25,
      }
    : {};

/**
 * Unfortunately, module mocking isn't really compatabile with how modules
 * work in JavaScript. This test needs to be done in isolation, meaning in
 * its own file and run separately from the other files. The error message
 * should throw if Chokidar is not installed, so this test isn't really
 * needed.
 */
// test('Should throw dedicated error message if Chokidar is not installed.', async () => {
//   try {
//     mock.module('chokidar', () => {
//       throw new Error('Cannot find package 'chokidar'');
//     });
//     await NodePlatform_Directory_Watch_Async(
//       temp_dir_path,
//       () => {},
//       () => {},
//     );
//     throw new Error('FAIL-CASE');
//   } catch (error: any) {
//     expect(error.message).toBe(Error_Message_NodePlatform_Directory_Create_Watcher_Async_Chokidar_Not_Installed);
//   }
// }, 1000);

beforeEach(async () => {
  async_globalUnwatch = undefined;
  expect(await NodePlatform_Directory_Create_Async(path_case_dir, true)).toBeTrue();
});
afterEach(async () => {
  await async_globalUnwatch?.();
  expect(await NodePlatform_Directory_Delete_Async(path_case_dir, true)).toBeTrue();
});

/**
 * Please thoroughly read the commentary in this file and in
 * "NodePlatform_Directory_Watch.js" if you plan on using this watch API
 * on WSL (Windows Subsystem for Linux). I've done my best to mitigate issues
 * when the program is running on WSL, but it's crucial that you and other
 * users understand the limitations and quirks of WSL around filesystem
 * notifications.
 */
test_pass = '#1';
describe(NodePlatform_Directory_Watch_Async.name, () => {
  test(`${test_pass} Should throw 'ENOENT' for non-existent path.`, async () => {
    try {
      await NodePlatform_Directory_Watch_Async(temp_nonexistent_path, () => {});
      throw new Error('FAIL-CASE');
    } catch (error: any) {
      expect(error.message).toStartWith('ENOENT: no such file or directory');
      expect(error.code).toBe('ENOENT');
    }
  }, 1000);

  test(`${test_pass} Should trigger 'addDir' event when directory is created on existent path.`, async () => {
    const expected_events = [
      //
      { event: 'addDir', path: path_case_dir_subdir },
    ];

    // setup
    // expect(await NodePlatform_Directory_Create_Async(path_case_dir, true)).toBeTrue();

    // watch
    const { events, exited } = await async_setupWatcher(path_case_dir, []);

    // steps
    expect(await NodePlatform_Directory_Create_Async(path_case_dir_subdir, true)).toBeTrue();
    await exited;
    checkEvents(events, expected_events);

    // clean
    // expect(await NodePlatform_Directory_Delete_Async(path_case_dir, true)).toBeTrue();
  }, 1000);

  // test(`${test_pass} Should trigger multiple 'addDir' events directory is created on non-existent path.`, async () => {
  //   const expected_events = [
  //     //
  //     { event: 'addDir', path: path_case_dir_subdir },
  //     { event: 'addDir', path: path_case_dir_subdir_subdir },
  //   ];
  //   const { events, exited } = await async_setupWatcher(path_case_dir, expected_events);

  //   expect(await NodePlatform_Directory_Create_Async(path_case_dir_subdir_subdir, true)).toBeTrue();
  //   await exited;
  //   checkEvents(events, expected_events);
  // }, 1000);

  // test(`${test_pass} Should trigger 'unlinkDir' event when directory is deleted.`, async () => {
  //   const expected_events = [
  //     //
  //     { event: 'addDir', path: path_case_dir_subdir },
  //     { event: 'unlinkDir', path: path_case_dir_subdir },
  //     { event: 'addDir', path: path_case_dir_subdir },
  //     { event: 'unlinkDir', path: path_case_dir_subdir },
  //     { event: 'addDir', path: path_case_dir_subdir },
  //     { event: 'unlinkDir', path: path_case_dir_subdir },
  //     { event: 'addDir', path: path_case_dir_subdir },
  //     { event: 'unlinkDir', path: path_case_dir_subdir },
  //     { event: 'addDir', path: path_case_dir_subdir },
  //     { event: 'unlinkDir', path: path_case_dir_subdir },
  //   ];
  // //   console.log('1');
  //   const { events, exited } = await async_setupWatcher(path_case_dir, expected_events);
  // //   console.log('2');

  //   expect(await NodePlatform_Directory_Create_Async(path_case_dir_subdir, true)).toBeTrue();
  //   expect(await NodePlatform_Directory_Delete_Async(path_case_dir_subdir, true)).toBeTrue();
  //   expect(await NodePlatform_Directory_Create_Async(path_case_dir_subdir, true)).toBeTrue();
  //   expect(await NodePlatform_Directory_Delete_Async(path_case_dir_subdir, true)).toBeTrue();
  //   expect(await NodePlatform_Directory_Create_Async(path_case_dir_subdir, true)).toBeTrue();
  //   expect(await NodePlatform_Directory_Delete_Async(path_case_dir_subdir, true)).toBeTrue();
  //   expect(await NodePlatform_Directory_Create_Async(path_case_dir_subdir, true)).toBeTrue();
  //   expect(await NodePlatform_Directory_Delete_Async(path_case_dir_subdir, true)).toBeTrue();
  //   expect(await NodePlatform_Directory_Create_Async(path_case_dir_subdir, true)).toBeTrue();
  //   expect(await NodePlatform_Directory_Delete_Async(path_case_dir_subdir, true)).toBeTrue();
  // //   console.log('3');
  //   await exited;
  // //   console.log('4');
  //   // checkEvents(events, expected_events);
  // }, 10000);

  // test(`${test_pass} Should trigger multiple 'unlinkDir' events when directory containing subdirectory is deleted.`, async () => {
  //   const { promise, resolve, reject } = Core_Promise_Deferred_Class();

  //   expect(await NodePlatform_Directory_Create_Async(path_case_dir_subdir_subdir, true)).toBeTrue();

  //   let event_count = 0;
  //   const { unwatch } = await NodePlatform_Directory_Watch_Async(
  //     path_case_dir,
  //     (event, path) => {
  //       switch (++event_count) {
  //         case 1:
  //           expect(event).toBe('unlinkDir');
  //           expect(path).toBe(path_case_dir_subdir_subdir);
  //           break;
  //         case 2:
  //           expect(event).toBe('unlinkDir');
  //           expect(path).toBe(path_case_dir_subdir);
  //           resolve();
  //           break;
  //       }
  //     },
  //     (error) => {
  //       reject(error);
  //     },
  //     watcher_options,
  //   );
  //   async_globalUnwatch = unwatch;

  //   expect(await NodePlatform_Directory_Delete_Async(path_case_dir_subdir, true)).toBeTrue();
  //   await promise;
  // }, 1000);

  // test(`${test_pass} Should trigger 'unlinkDir' and 'unlink' events when directory containing file is deleted.`, async () => {
  //   const { promise, resolve, reject } = Core_Promise_Deferred_Class();

  //   await NodePlatform_File_Write_Text_Async(path_case_dir_subdir_file, 'ABC');
  //   expect(await NodePlatform_File_Read_Text_Async(path_case_dir_subdir_file)).toBe('ABC');

  //   let event_count = 0;
  //   const { unwatch } = await NodePlatform_Directory_Watch_Async(
  //     path_case_dir,
  //     (event, path) => {
  //       switch (++event_count) {
  //         case 1:
  //           expect(event).toBe('unlinkDir');
  //           expect(path).toBe(path_case_dir_subdir);
  //           break;
  //         case 2:
  //           expect(event).toBe('unlink');
  //           expect(path).toBe(path_case_dir_subdir_file);
  //           resolve();
  //           break;
  //       }
  //     },
  //     (error) => {
  //       reject(error);
  //     },
  //     watcher_options,
  //   );
  //   async_globalUnwatch = unwatch;

  //   expect(await NodePlatform_Directory_Delete_Async(path_case_dir_subdir, true)).toBeTrue();
  //   await promise;
  // }, 1000);

  // test(`${test_pass} Should trigger 'add' event when calling append on non-existent file on existent path.`, async () => {
  //   const { promise, resolve, reject } = Core_Promise_Deferred_Class();

  //   const { unwatch } = await NodePlatform_Directory_Watch_Async(
  //     path_case_dir,
  //     (event, path) => {
  //       expect(event).toBe('add');
  //       expect(path).toBe(path_case_dir_file);
  //       resolve();
  //     },
  //     (error) => {
  //       reject(error);
  //     },
  //     watcher_options,
  //   );
  //   async_globalUnwatch = unwatch;

  //   await NodePlatform_File_Append_Text_Async(path_case_dir_file, 'ABC');
  //   expect(await NodePlatform_File_Read_Text_Async(path_case_dir_file)).toBe('ABC');
  //   await promise;
  // }, 1000);

  // test(`${test_pass} Should trigger 'add' event when calling write on non-existent file on existent path.`, async () => {
  //   const { promise, resolve, reject } = Core_Promise_Deferred_Class();

  //   const { unwatch } = await NodePlatform_Directory_Watch_Async(
  //     path_case_dir,
  //     (event, path) => {
  //       expect(event).toBe('add');
  //       expect(path).toBe(path_case_dir_file);
  //       resolve();
  //     },
  //     (error) => {
  //       reject(error);
  //     },
  //     watcher_options,
  //   );
  //   async_globalUnwatch = unwatch;

  //   await NodePlatform_File_Write_Text_Async(path_case_dir_file, 'ABC');
  //   expect(await NodePlatform_File_Read_Text_Async(path_case_dir_file)).toBe('ABC');
  //   await promise;
  // }, 1000);

  // test(`${test_pass} Should trigger 'addDir' and 'add' events when calling append on non-existent file on non-existent path.`, async () => {
  //   const { promise, resolve, reject } = Core_Promise_Deferred_Class();

  //   /**
  //    * why does this break other tests??
  //    */
  //   let event_count = 0;
  //   const { unwatch } = await NodePlatform_Directory_Watch_Async(
  //     path_case_dir,
  //     (event, path) => {
  //       switch (++event_count) {
  //         case 1:
  //           expect(event).toBe('addDir');
  //           expect(path).toBe(path_case_dir_subdir);
  //           break;
  //         case 2:
  //           expect(event).toBe('add');
  //           expect(path).toBe(path_case_dir_subdir_file);
  //           resolve();
  //           break;
  //       }
  //     },
  //     (error) => {
  //       reject(error);
  //     },
  //     watcher_options,
  //   );
  //   async_globalUnwatch = unwatch;

  //   await NodePlatform_File_Append_Text_Async(path_case_dir_subdir_file, 'ABC');
  //   expect(await NodePlatform_File_Read_Text_Async(path_case_dir_subdir_file)).toBe('ABC');
  //   await promise;
  // }, 1000);

  // test(`${test_pass} Should trigger 'addDir' and 'add' events when calling write on non-existent file on non-existent path.`, async () => {
  //   const { promise, resolve, reject } = Core_Promise_Deferred_Class();

  //   let event_count = 0;
  //   const { unwatch } = await NodePlatform_Directory_Watch_Async(
  //     path_case_dir,
  //     (event, path) => {
  //       switch (++event_count) {
  //         case 1:
  //           expect(event).toBe('addDir');
  //           expect(path).toBe(path_case_dir_subdir);
  //           break;
  //         case 2:
  //           expect(event).toBe('add');
  //           expect(path).toBe(path_case_dir_subdir_file);
  //           resolve();
  //           break;
  //       }
  //     },
  //     (error) => {
  //       reject(error);
  //     },
  //     watcher_options,
  //   );
  //   async_globalUnwatch = unwatch;

  //   await NodePlatform_File_Write_Text_Async(path_case_dir_subdir_file, 'ABC');
  //   expect(await NodePlatform_File_Read_Text_Async(path_case_dir_subdir_file)).toBe('ABC');
  //   await promise;
  // }, 1000);

  // test(`${test_pass} Should trigger 'unlink' event when file is deleted.`, async () => {
  //   const { promise, resolve, reject } = Core_Promise_Deferred_Class();

  //   await NodePlatform_File_Write_Text_Async(path_case_dir_subdir_file, 'ABC');
  //   expect(await NodePlatform_File_Read_Text_Async(path_case_dir_subdir_file)).toBe('ABC');

  //   const { unwatch } = await NodePlatform_Directory_Watch_Async(
  //     path_case_dir,
  //     (event, path) => {
  //       expect(event).toBe('unlink');
  //       expect(path).toBe(path_case_dir_subdir_file);
  //       resolve();
  //     },
  //     (error) => {
  //       reject(error);
  //     },
  //     watcher_options,
  //   );
  //   async_globalUnwatch = unwatch;

  //   expect(await NodePlatform_File_Delete_Async(path_case_dir_subdir_file)).toBeTrue();
  //   await promise;
  // }, 1000);

  // test(`${test_pass} Should trigger 'change' event when calling append on existent file.`, async () => {
  //   const { promise, resolve, reject } = Core_Promise_Deferred_Class();

  //   await NodePlatform_File_Write_Text_Async(path_case_dir_file, 'ABC');
  //   expect(await NodePlatform_File_Read_Text_Async(path_case_dir_file)).toBe('ABC');

  //   const { unwatch } = await NodePlatform_Directory_Watch_Async(
  //     path_case_dir,
  //     (event, path) => {
  // //       console.log({ event, path });
  //       expect(event).toBe('change');
  //       expect(path).toBe(path_case_dir_file);
  //       resolve();
  //     },
  //     (error) => {
  //       reject(error);
  //     },
  //     watcher_options,
  //   );
  //   async_globalUnwatch = unwatch;

  //   await NodePlatform_File_Append_Text_Async(path_case_dir_file, 'DEF');
  //   expect(await NodePlatform_File_Read_Text_Async(path_case_dir_file)).toBe('ABCDEF');
  //   await promise;
  // }, 1000);

  // test(`${test_pass} Should trigger 'change' event when calling write on existent file.`, async () => {
  //   const { promise, resolve, reject } = Core_Promise_Deferred_Class();

  //   await NodePlatform_File_Write_Text_Async(path_case_dir_file, 'ABC');
  //   expect(await NodePlatform_File_Read_Text_Async(path_case_dir_file)).toBe('ABC');

  //   const { unwatch } = await NodePlatform_Directory_Watch_Async(
  //     path_case_dir,
  //     (event, path) => {
  // //       console.log({ event, path });
  //       expect(event).toBe('change');
  //       expect(path).toBe(path_case_dir_file);
  //       resolve();
  //     },
  //     (error) => {
  //       reject(error);
  //     },
  //     watcher_options,
  //   );
  //   async_globalUnwatch = unwatch;

  //   await NodePlatform_File_Write_Text_Async(path_case_dir_file, 'DEF');
  //   expect(await NodePlatform_File_Read_Text_Async(path_case_dir_file)).toBe('DEF');
  //   await promise;
  // }, 1000);

  // //## Edge Cases

  // test(`${test_pass} Should do nothing when empty watch directory is deleted.`, async () => {
  //   const { promise, resolve, reject } = Core_Promise_Deferred_Class();

  //   const { unwatch } = await NodePlatform_Directory_Watch_Async(
  //     path_case_dir,
  //     (event, path) => {
  //       reject('FAIL-CASE');
  //     },
  //     (error) => {
  //       reject(error);
  //     },
  //     watcher_options,
  //   );
  //   async_globalUnwatch = unwatch;

  //   expect(await NodePlatform_Directory_Delete_Async(path_case_dir, true)).toBeTrue();

  //   setTimeout(() => resolve(), 250);
  //   await promise;
  // }, 1000);

  // test(`${test_pass} Should trigger 'unlink' event when non-empty watch directory is deleted.`, async () => {
  //   const { promise, resolve, reject } = Core_Promise_Deferred_Class();

  //   await NodePlatform_File_Append_Text_Async(path_case_dir_file, 'ABC');
  //   expect(await NodePlatform_File_Read_Text_Async(path_case_dir_file)).toBe('ABC');

  //   let event_count = 0;
  //   const { unwatch } = await NodePlatform_Directory_Watch_Async(
  //     path_case_dir,
  //     (event, path) => {
  //       switch (++event_count) {
  //         case 1:
  //           expect(event).toBe('unlinkDir');
  //           expect(path).toBe(path_case_dir);
  //           break;
  //         case 2:
  //           expect(event).toBe('unlink');
  //           expect(path).toBe(path_case_dir_file);
  //           resolve();
  //           break;
  //       }
  //     },
  //     (error) => {
  //       reject(error);
  //     },
  //     watcher_options,
  //   );
  //   async_globalUnwatch = unwatch;

  //   expect(await NodePlatform_Directory_Delete_Async(path_case_dir, true)).toBeTrue();

  //   setTimeout(() => resolve(), 250);
  //   await promise;
  // }, 1000);
});

test_pass = '#2';
// describe(NodePlatform_Directory_Watch_Async.name, () => {
//   let GlobalUnwatch: Function | undefined;
//   beforeEach(async () => {
//     GlobalUnwatch = undefined;
//     await NodePlatform_Directory_Create_Async(path_case_dir, true);
//   });
//   afterEach(async () => {
//     await GlobalUnwatch?.();
//     await NodePlatform_Directory_Delete_Async(path_case_dir, true);
//   });

//   /**
//    * Unfortunately, module mocking isn't really compatabile with how modules
//    * work in JavaScript. This test needs to be done in isolation, meaning in
//    * its own file and run separately from the other files. The error message
//    * should throw if Chokidar is not installed, so this test isn't really
//    * needed.
//    */
//   /**
//    * test('Should throw dedicated error message if Chokidar is not installed.', async () => {
//    *   try {
//    *     mock.module('chokidar', () => {
//    *       throw new Error('Cannot find package 'chokidar'');
//    *     });
//    *     await NodePlatform_Directory_Watch_Async(
//    *       case_dir_path,
//    *       () => {},
//    *       () => {},
//    *     );
//    *     throw new Error('FAIL-CASE');
//    *   } catch (error: any) {
//    *     expect(error.message).toBe(Error_Message_NodePlatform_Directory_Create_Watcher_Async_Chokidar_Not_Installed);
//    *   }
//    * }, 1000);
//    */

//   test(`${test_pass} Should throw 'ENOENT' for non-existent path.`, async () => {
//     try {
//       const { unwatch } = await NodePlatform_Directory_Watch_Async(
//         temp_nonexistent_path,
//         () => {},
//         () => {},
//       );
//       GlobalUnwatch = unwatch;
//       throw new Error('FAIL-CASE');
//     } catch (error: any) {
//       expect(error.message).toStartWith('ENOENT: no such file or directory');
//       expect(error.code).toBe('ENOENT');
//     }
//   }, 1000);

//   test(`${test_pass} Should trigger 'addDir' event when directory is created on existent path.`, async () => {
//     const { promise, resolve, reject } = Core_Promise_Deferred_Class();

//     const { unwatch } = await NodePlatform_Directory_Watch_Async(
//       path_case_dir,
//       (event, path) => {
//         expect(event).toBe('addDir');
//         expect(path).toBe(path_case_dir_subdir);
//         resolve();
//       },
//       (error) => {
//         reject(error);
//       },
//       watcher_options,
//     );
//     GlobalUnwatch = unwatch;

//     expect(await NodePlatform_Directory_Create_Async(path_case_dir_subdir, true)).toBeTrue();
//     await promise;
//   }, 1000);

//   test(`${test_pass} Should trigger multiple 'addDir' events directory is created on non-existent path.`, async () => {
//     const { promise, resolve, reject } = Core_Promise_Deferred_Class();

//     let event_count = 0;
//     const { unwatch } = await NodePlatform_Directory_Watch_Async(
//       path_case_dir,
//       (event, path) => {
//         switch (++event_count) {
//           case 1:
//             expect(event).toBe('addDir');
//             expect(path).toBe(path_case_dir_subdir);
//             break;
//           case 2:
//             expect(event).toBe('addDir');
//             expect(path).toBe(path_case_dir_subdir_subdir);
//             resolve();
//             break;
//         }
//       },
//       (error) => {
//         reject(error);
//       },
//       watcher_options,
//     );
//     GlobalUnwatch = unwatch;

//     expect(await NodePlatform_Directory_Create_Async(path_case_dir_subdir_subdir, true)).toBeTrue();
//     await promise;
//   }, 1000);

//   test(`${test_pass} Should trigger 'unlinkDir' event when directory is deleted.`, async () => {
//     const { promise, resolve, reject } = Core_Promise_Deferred_Class();

//     expect(await NodePlatform_Directory_Create_Async(path_case_dir_subdir, true)).toBeTrue();

//     const { unwatch } = await NodePlatform_Directory_Watch_Async(
//       path_case_dir,
//       (event, path) => {
//         expect(event).toBe('unlinkDir');
//         expect(path).toBe(path_case_dir_subdir);
//         resolve();
//       },
//       (error) => {
//         reject(error);
//       },
//       watcher_options,
//     );
//     GlobalUnwatch = unwatch;

//     expect(await NodePlatform_Directory_Delete_Async(path_case_dir_subdir, true)).toBeTrue();
//     await promise;
//   }, 1000);

//   test(`${test_pass} Should trigger multiple 'unlinkDir' events when directory containing subdirectory is deleted.`, async () => {
//     const { promise, resolve, reject } = Core_Promise_Deferred_Class();

//     expect(await NodePlatform_Directory_Create_Async(path_case_dir_subdir_subdir, true)).toBeTrue();

//     let event_count = 0;
//     const { unwatch } = await NodePlatform_Directory_Watch_Async(
//       path_case_dir,
//       (event, path) => {
//         switch (++event_count) {
//           case 1:
//             expect(event).toBe('unlinkDir');
//             expect(path).toBe(path_case_dir_subdir_subdir);
//             break;
//           case 2:
//             expect(event).toBe('unlinkDir');
//             expect(path).toBe(path_case_dir_subdir);
//             resolve();
//             break;
//         }
//       },
//       (error) => {
//         reject(error);
//       },
//       watcher_options,
//     );
//     GlobalUnwatch = unwatch;

//     expect(await NodePlatform_Directory_Delete_Async(path_case_dir_subdir, true)).toBeTrue();
//     await promise;
//   }, 1000);

//   test(`${test_pass} Should trigger 'unlinkDir' and 'unlink' events when directory containing file is deleted.`, async () => {
//     const { promise, resolve, reject } = Core_Promise_Deferred_Class();

//     await NodePlatform_File_Write_Text_Async(path_case_dir_subdir_file, 'ABC');
//     expect(await NodePlatform_File_Read_Text_Async(path_case_dir_subdir_file)).toBe('ABC');

//     let event_count = 0;
//     const { unwatch } = await NodePlatform_Directory_Watch_Async(
//       path_case_dir,
//       (event, path) => {
//         switch (++event_count) {
//           case 1:
//             expect(event).toBe('unlinkDir');
//             expect(path).toBe(path_case_dir_subdir);
//             break;
//           case 2:
//             expect(event).toBe('unlink');
//             expect(path).toBe(path_case_dir_subdir_file);
//             resolve();
//             break;
//         }
//       },
//       (error) => {
//         reject(error);
//       },
//       watcher_options,
//     );
//     GlobalUnwatch = unwatch;

//     expect(await NodePlatform_Directory_Delete_Async(path_case_dir_subdir, true)).toBeTrue();
//     await promise;
//   }, 1000);

//   test(`${test_pass} Should trigger 'add' event when calling append on non-existent file on existent path.`, async () => {
//     const { promise, resolve, reject } = Core_Promise_Deferred_Class();

//     const { unwatch } = await NodePlatform_Directory_Watch_Async(
//       path_case_dir,
//       (event, path) => {
//         expect(event).toBe('add');
//         expect(path).toBe(path_case_dir_file);
//         resolve();
//       },
//       (error) => {
//         reject(error);
//       },
//       watcher_options,
//     );
//     GlobalUnwatch = unwatch;

//     await NodePlatform_File_Append_Text_Async(path_case_dir_file, 'ABC');
//     expect(await NodePlatform_File_Read_Text_Async(path_case_dir_file)).toBe('ABC');
//     await promise;
//   }, 1000);

//   test(`${test_pass} Should trigger 'add' event when calling write on non-existent file on existent path.`, async () => {
//     const { promise, resolve, reject } = Core_Promise_Deferred_Class();

//     const { unwatch } = await NodePlatform_Directory_Watch_Async(
//       path_case_dir,
//       (event, path) => {
//         expect(event).toBe('add');
//         expect(path).toBe(path_case_dir_file);
//         resolve();
//       },
//       (error) => {
//         reject(error);
//       },
//       watcher_options,
//     );
//     GlobalUnwatch = unwatch;

//     await NodePlatform_File_Write_Text_Async(path_case_dir_file, 'ABC');
//     expect(await NodePlatform_File_Read_Text_Async(path_case_dir_file)).toBe('ABC');
//     await promise;
//   }, 1000);

//   test(`${test_pass} Should trigger 'addDir' and 'add' events when calling append on non-existent file on non-existent path.`, async () => {
//     const { promise, resolve, reject } = Core_Promise_Deferred_Class();

//     /**
//      * why does this break other tests??
//      */
//     let event_count = 0;
//     const { unwatch } = await NodePlatform_Directory_Watch_Async(
//       path_case_dir,
//       (event, path) => {
//         switch (++event_count) {
//           case 1:
//             expect(event).toBe('addDir');
//             expect(path).toBe(path_case_dir_subdir);
//             break;
//           case 2:
//             expect(event).toBe('add');
//             expect(path).toBe(path_case_dir_subdir_file);
//             resolve();
//             break;
//         }
//       },
//       (error) => {
//         reject(error);
//       },
//       watcher_options,
//     );
//     GlobalUnwatch = unwatch;

//     await NodePlatform_File_Append_Text_Async(path_case_dir_subdir_file, 'ABC');
//     expect(await NodePlatform_File_Read_Text_Async(path_case_dir_subdir_file)).toBe('ABC');
//     await promise;
//   }, 1000);

//   test(`${test_pass} Should trigger 'addDir' and 'add' events when calling write on non-existent file on non-existent path.`, async () => {
//     const { promise, resolve, reject } = Core_Promise_Deferred_Class();

//     let event_count = 0;
//     const { unwatch } = await NodePlatform_Directory_Watch_Async(
//       path_case_dir,
//       (event, path) => {
//         switch (++event_count) {
//           case 1:
//             expect(event).toBe('addDir');
//             expect(path).toBe(path_case_dir_subdir);
//             break;
//           case 2:
//             expect(event).toBe('add');
//             expect(path).toBe(path_case_dir_subdir_file);
//             resolve();
//             break;
//         }
//       },
//       (error) => {
//         reject(error);
//       },
//       watcher_options,
//     );
//     GlobalUnwatch = unwatch;

//     await NodePlatform_File_Write_Text_Async(path_case_dir_subdir_file, 'ABC');
//     expect(await NodePlatform_File_Read_Text_Async(path_case_dir_subdir_file)).toBe('ABC');
//     await promise;
//   }, 1000);

//   test(`${test_pass} Should trigger 'unlink' event when file is deleted.`, async () => {
//     const { promise, resolve, reject } = Core_Promise_Deferred_Class();

//     await NodePlatform_File_Write_Text_Async(path_case_dir_subdir_file, 'ABC');
//     expect(await NodePlatform_File_Read_Text_Async(path_case_dir_subdir_file)).toBe('ABC');

//     const { unwatch } = await NodePlatform_Directory_Watch_Async(
//       path_case_dir,
//       (event, path) => {
//         expect(event).toBe('unlink');
//         expect(path).toBe(path_case_dir_subdir_file);
//         resolve();
//       },
//       (error) => {
//         reject(error);
//       },
//       watcher_options,
//     );
//     GlobalUnwatch = unwatch;

//     expect(await NodePlatform_File_Delete_Async(path_case_dir_subdir_file)).toBeTrue();
//     await promise;
//   }, 1000);

//   test(`${test_pass} Should trigger 'change' event when calling append on existent file.`, async () => {
//     const { promise, resolve, reject } = Core_Promise_Deferred_Class();

//     await NodePlatform_File_Write_Text_Async(path_case_dir_file, 'ABC');
//     expect(await NodePlatform_File_Read_Text_Async(path_case_dir_file)).toBe('ABC');

//     const { unwatch } = await NodePlatform_Directory_Watch_Async(
//       path_case_dir,
//       (event, path) => {
// //         console.log({ event, path });
//         expect(event).toBe('change');
//         expect(path).toBe(path_case_dir_file);
//         resolve();
//       },
//       (error) => {
//         reject(error);
//       },
//       watcher_options,
//     );
//     GlobalUnwatch = unwatch;

//     await NodePlatform_File_Append_Text_Async(path_case_dir_file, 'DEF');
//     expect(await NodePlatform_File_Read_Text_Async(path_case_dir_file)).toBe('ABCDEF');
//     await promise;
//   }, 1000);

//   test(`${test_pass} Should trigger 'change' event when calling write on existent file.`, async () => {
//     const { promise, resolve, reject } = Core_Promise_Deferred_Class();

//     const { unwatch } = await NodePlatform_Directory_Watch_Async(
//       path_case_dir,
//       (event, path) => {
// //         console.log({ event, path });
//         expect(event).toBe('change');
//         expect(path).toBe(path_case_dir_file);
//         resolve();
//       },
//       (error) => {
//         reject(error);
//       },
//       watcher_options,
//     );
//     GlobalUnwatch = unwatch;

//     await NodePlatform_File_Write_Text_Async(path_case_dir_file, 'ABC');
//     expect(await NodePlatform_File_Read_Text_Async(path_case_dir_file)).toBe('ABC');
//     await NodePlatform_File_Write_Text_Async(path_case_dir_file, 'DEF');
//     expect(await NodePlatform_File_Read_Text_Async(path_case_dir_file)).toBe('DEF');
//     await promise;
//   }, 1000);

//   //## Edge Cases

//   test(`${test_pass} Should do nothing when empty watch directory is deleted.`, async () => {
//     const { promise, resolve, reject } = Core_Promise_Deferred_Class();

//     const { unwatch } = await NodePlatform_Directory_Watch_Async(
//       path_case_dir,
//       (event, path) => {
//         reject('FAIL-CASE');
//       },
//       (error) => {
//         reject(error);
//       },
//       watcher_options,
//     );
//     GlobalUnwatch = unwatch;

//     expect(await NodePlatform_Directory_Delete_Async(path_case_dir, true)).toBeTrue();

//     setTimeout(() => resolve(), 250);
//     await promise;
//   }, 1000);

//   test(`${test_pass} Should trigger 'unlink' event when non-empty watch directory is deleted.`, async () => {
//     const { promise, resolve, reject } = Core_Promise_Deferred_Class();

//     await NodePlatform_File_Append_Text_Async(path_case_dir_file, 'ABC');
//     expect(await NodePlatform_File_Read_Text_Async(path_case_dir_file)).toBe('ABC');

//     let event_count = 0;
//     const { unwatch } = await NodePlatform_Directory_Watch_Async(
//       path_case_dir,
//       (event, path) => {
//         switch (++event_count) {
//           case 1:
//             expect(event).toBe('unlinkDir');
//             expect(path).toBe(path_case_dir);
//             break;
//           case 2:
//             expect(event).toBe('unlink');
//             expect(path).toBe(path_case_dir_file);
//             resolve();
//             break;
//         }
//       },
//       (error) => {
//         reject(error);
//       },
//       watcher_options,
//     );
//     GlobalUnwatch = unwatch;

//     expect(await NodePlatform_Directory_Delete_Async(path_case_dir, true)).toBeTrue();

//     setTimeout(() => resolve(), 250);
//     await promise;
//   }, 1000);
// });

async function async_setupWatcher(
  watch_path: string,
  expected_events: { event: string; path: string }[],
): Promise<{
  events: { event: string; path: string }[];
  exited: Promise<void>;
}> {
  // console.log('async_setupWatcher: 1');
  const { promise, resolve, reject } = Core_Promise_Deferred_Class();
  // console.log('async_setupWatcher: 2');
  const events: { event: string; path: string }[] = [];
  // console.log('async_setupWatcher: 3');
  const { unwatch } = await NodePlatform_Directory_Watch_Async(
    watch_path,
    (args) => {
      console.log(args);
      // console.log('async_setupWatcher: 4');
      // events.push({ event, path });
      // console.log('async_setupWatcher: 5');
      // if (events.length >= expected_events.length) {
      // //   console.log('async_setupWatcher: 6');
      //   resolve();
      // //   console.log('async_setupWatcher: 7');
      // }
      // // console.log('async_setupWatcher: 8');
    },
    watcher_options,
  );
  // console.log('async_setupWatcher: 11');
  async_globalUnwatch = unwatch;
  // console.log('async_setupWatcher: 12');
  return { events, exited: promise };
}

function checkEvents(received_events: { event: string; path: string }[], expected_events: { event: string; path: string }[]) {
  // // console.log({ received_events, expected_events });
  expect(received_events.map((item, i) => `${i} - ${item.event}: '${item.path}'`)).toEqual(expected_events.map((item, i) => `${i} - ${item.event}: '${item.path}'`));
}
